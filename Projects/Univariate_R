# Version - 4.5 -----------------------------------------------------------
# Change log: CG Inference and UL Inference Included

# Setting up Workspace ----------------------------------------------------
ls()
rm(list=ls())
library(tidyr)
library(dplyr)
library(forecast)
workingDir <- choose.dir(default = "D:/", caption = "Select Working Directory")
#workingDir <- "D:/Storage/Test/Master BL"
setwd(workingDir)
#wd<-getwd()

# Read Input Files --------------------------------------------------------
inputParam <- read.csv("Input Param.csv", stringsAsFactors = FALSE)
salesInput<-read.csv("Sales Input.csv",stringsAsFactors = FALSE)
movAvgWts<-read.csv("WTS.csv",stringsAsFactors = FALSE)
colnames(inputParam) <- c("Parameter", "Value", "Instruction")
sdRfrsh <- NULL

# Input Parameters --------------------------------------------------------
MasterVersion <- 4.5 
if (MasterVersion != inputParam$Value[1]) {
  winDialog(type = c("ok"), "Error in Input Version")
  stop("Version Mismatch")
}
unitPeriodLen <- NULL
snlPeriod <- NULL
monthFlag <- as.numeric(inputParam$Value[2])
runMode <- as.numeric(inputParam$Value[3])
lagsCount <- as.numeric(inputParam$Value[4])
lagPeriodLen <- as.numeric(inputParam$Value[5])
sparseInterval <- as.numeric(inputParam$Value[6])
newProdPeriod <- as.numeric(inputParam$Value[7])
recentPeriod <- as.numeric(inputParam$Value[8])
cshMethod <- as.numeric(inputParam$Value[9])
seasTest <- as.numeric(inputParam$Value[10])
inputUCL<- as.numeric(inputParam$Value[11])
inputLCL<- as.numeric(inputParam$Value[12])
forecastDuration <- as.numeric(inputParam$Value[13])
meanDuration <- as.numeric(inputParam$Value[14])
plotsFlag <- as.numeric(inputParam$Value[15])
fittedFlag <- as.numeric(inputParam$Value[16])
crostonAlpha <- as.numeric(inputParam$Value[17])
etsModel <- inputParam$Value[18]
etsMaxAlpha <- as.numeric(inputParam$Value[19])
etsMaxBeta <- as.numeric(inputParam$Value[20])
etsMaxGamma <- as.numeric(inputParam$Value[21])
etsMaxPhi <- as.numeric(inputParam$Value[22])
crostonFlag <- as.numeric(inputParam$Value[23])
tsinterFlag <- as.numeric(inputParam$Value[24])
naiveFlag <- as.numeric(inputParam$Value[25])
meanFlag <- as.numeric(inputParam$Value[26])
etsFlag <- as.numeric(inputParam$Value[27])
arimaFlag <- as.numeric(inputParam$Value[28])
stlEtsFlag <- as.numeric(inputParam$Value[29])
tbatsFlag <- as.numeric(inputParam$Value[30])
arimaRegFlag <- as.numeric(inputParam$Value[31])
nnetarFlag <- as.numeric(inputParam$Value[32])
hwFlag<- as.numeric(inputParam$Value[33])
linearRegFlag<- as.numeric(inputParam$Value[34])
csEtsFlag<- as.numeric(inputParam$Value[35])

if(monthFlag==1){
  unitPeriodLen <- 12
  sdRfrsh <- read.csv("SDRFRSH_Month.csv",stringsAsFactors = FALSE)
}else{
  unitPeriodLen <- 52
  sdRfrsh <- read.csv("SDRFRSH_Week.csv",stringsAsFactors = FALSE)
}
snlPeriod <- unitPeriodLen/4
salesPatterns <- NULL
cshOutput <- NULL
sdValue <- NULL
refreshTimes <- NULL
fctOutput <- NULL
fctFit <- NULL
DSHWFlagDF<- NULL
DSHWFlagDF<- as.data.frame(DSHWFlagDF,stringsAsFactors = FALSE)
fctParam <- cbind("Key"= "DummyKey",
                   "Alpha" =  "NA",
                   "Beta" = "NA",
                   "Gamma1" = "NA",
                   "Gamma2" = "NA",
                   "Damp" = "NA",
                   "p" = "NA",
                   "d" = "NA",
                   "q" = "NA",
                   "Type" = "NA",
                   "Model" = "NA")
fctParam <- as.data.frame(fctParam,stringsAsFactors = FALSE)

# Period Master -----------------------------------------------------------
periodMasterStarYr <- 2010
periodMasterEndYr <- 2030
getPeriodMaster <- function(startYr, endYr){
  periodMaster <- NULL
  for (i in startYr:endYr) {
    yr <- i * 100
    periods <- c((yr+1):(yr+unitPeriodLen))
    periodMaster <- c(periodMaster,periods)
  }
  return(periodMaster)
}
periodMaster <- getPeriodMaster(periodMasterStarYr, periodMasterEndYr)

# Data Sanitation ---------------------------------------------------------
cshInputAll <- salesInput
colnames(cshInputAll) <- c("Key", "Period", "Sales")
cshInputAll$Period <- as.numeric(cshInputAll$Period )
cshInputAll$Sales <- as.numeric(cshInputAll$Sales )
minPeriodIndex <- match(min(cshInputAll$Period),periodMaster)
maxPeriodIndex <- match(max(cshInputAll$Period),periodMaster)
allSalePeriod<-periodMaster[minPeriodIndex:maxPeriodIndex]
allSalePeriodLen <- length(allSalePeriod)
dummySaleDF <- data.frame("Key" = c("DummyKey"))
dummySaleDF <- cbind(dummySaleDF, "Period"=allSalePeriod, "Sales" = 0)
cshInputAll <- rbind(cshInputAll, dummySaleDF)
cshInputAll[is.na(cshInputAll)] <- 0
cshInputAll$Sales[cshInputAll$Sales<0]<-0
cshInputAll <- arrange(cshInputAll,Key,Period)
group_by(cshInputAll,"Key","Period")
cshInputAll <- spread(cshInputAll, Period, Sales)
cshInputAll[is.na(cshInputAll)] <- 0
cshInputAll <- gather(cshInputAll,"Period","Sales", 2:ncol(cshInputAll))
cshInputAll<- filter(cshInputAll, Key != "DummyKey")
cshInputAll <- arrange(cshInputAll,Key,Period)
write.csv(cshInputAll, file = "CSH Input All.csv", row.names = FALSE)

#Sales Data Length
getSaleStart <- function(salesData,salesLen){
  saleStart <- 1
  for (j in 1:salesLen) {
    if (salesData[j] > 0) {
      saleStart <- j
      break
    } else{
      j <- j + 1
    }
  }
  return(saleStart)
}

getKWresult <- function(actualSales, periodIndex){
  kwTest <- NULL
  kwTest <- kruskal.test(actualSales, periodIndex)
  if(kwTest$p.value <= 0.05){
    salesInfo <- "Seasonal"
  }else{
    salesInfo <- "Non Seasonal"
  }
  return(salesInfo)
}

getSalesInfo <- function(actualSales, salesCount, salesPeriod){
  periodIndex <- as.numeric(substring(salesPeriod, 5,6))
  if(sum(actualSales)==0){
    salesInfo <- "Sparse"
  }else{
    salesFact <- length(actualSales[actualSales == 0]) / salesCount
    if((salesCount - (sparseInterval - 1))<0){
      salesInfo <- "New Product"
    }else{
      if (sum(actualSales[(salesCount - (sparseInterval - 1)):salesCount]) == 0) {
        if(salesCount<=(2*unitPeriodLen)){
          salesInfo <- "Sparse"
        }else{
          if(getKWresult(actualSales, periodIndex) == "Seasonal"){
            salesInfo <- "Intermittent - Seasonal"
          }else{
            salesInfo <- "Sparse"
          }
        }
      }else{
        if (salesCount <= recentPeriod) {
          salesInfo <- "Recent"
          if(salesCount <= newProdPeriod){
            salesInfo <- "New Product"
          }
        } else{
          if (salesFact > 0.8) {
            salesInfo <- "Sparse"
          } else{
            if (salesFact < 0.25) {
              if(salesCount<=(2*unitPeriodLen)){
                salesInfo <- "Regular - Non Seasonal"
              }else{
                if(seasTest == 1){
                  salesInfo <- paste("Regular -",getKWresult(actualSales, periodIndex)) 
                }else{
                  salesInfo <- "Regular - Seasonal"
                }
              }
            } else{
              if(salesCount<=(2*unitPeriodLen)){
                salesInfo <- "Intermittent - Non Seasonal"
              }else{
                  salesInfo <- paste("Intermittent -",getKWresult(actualSales, periodIndex))
              }
            }
          }
        }
      }
    } 
  }
  return(salesInfo)
}

appendSalesInfo <- function(salesKey,salesInfo,salesCount,saleStart){
  if(is.null(salesPatterns)){
    salesPatterns <<- cbind("Key"=salesKey,
                        "Sales Info"=salesInfo, 
                        "Sales Count"= salesCount,
                        "Sales Start"=saleStart)
    salesPatterns <<- as.data.frame(salesPatterns,stringsAsFactors = FALSE)
  }else{
    tempsalesPatterns <- cbind("Key"=salesKey,
                           "Sales Info"=salesInfo, 
                           "Sales Count"= salesCount,
                           "Sales Start"=saleStart)
    salesPatterns <<- rbind(salesPatterns,tempsalesPatterns)
  }
}

popsd <- function (x, nomiss = 0.8){
  miss <- sum(is.na(x))
  comp <- (length(x) - miss)/length(x)
  out <- ifelse(comp >= nomiss, sqrt((var(x, na.rm = T) * (length(x) - miss - 1))/(length(x) - miss)), NA)
  return(out)
}

resetInputFactors <- function(salesInfo, salesCount){
  sdRfrshInput <- filter(sdRfrsh, Type == salesInfo)
  if(salesCount>sdRfrshInput$Time[1]){
    sdValue <<- sdRfrshInput$SD[1]
    refreshTimes <<- sdRfrshInput$Refresh[1]
  }else{
    if(salesCount>sdRfrshInput$Time[2]){
      sdValue <<- sdRfrshInput$SD[2]
      refreshTimes <<- sdRfrshInput$Refresh[2]
    }else{
      sdValue <<- sdRfrshInput$SD[3]
      refreshTimes <<- sdRfrshInput$Refresh[3]
    }
  }
}

removeOutliers <- function(salesData){
  tempSalesData <- salesData
  tempSalesMean <- mean(tempSalesData)
  tempSalesStdDev <- popsd(tempSalesData)
  tempSalesOutlier <- tempSalesMean + (sdValue * tempSalesStdDev)
  tempSalesMax <- max(tempSalesData)
  
  loopItr <- 0
  if(tempSalesMax>tempSalesOutlier){
    while(loopItr!=refreshTimes){
      outlierIndex <- match(tempSalesMax, tempSalesData)
      tempSalesData[outlierIndex]<-0
      tempSalesMean <- mean(tempSalesData)
      tempSalesStdDev <- popsd(tempSalesData)
      tempSalesOutlier <- tempSalesMean + (sdValue * tempSalesStdDev)
      tempSalesMax <- max(tempSalesData)
      if(tempSalesMax>tempSalesOutlier){
        loopItr <- loopItr + 1
      }else{
        break
      }
    }
  }
  tempSalesData[!(salesData==tempSalesData)] <- tempSalesOutlier
  return(tempSalesData)
}

calculateMovAvg <- function(salesData){
  tempCsh1 <- salesData
  tempMovAvg <- tempCsh1
  tempMovlen <- length(tempMovAvg)
  
  for(t in 1:tempMovlen){
    if(t==1){
      tempMovAvg[t] <- ((tempCsh1[t]*movAvgWts$first[5])
                        +(tempCsh1[t+1]*movAvgWts$first[6])
                        +(tempCsh1[t+2]*movAvgWts$first[7])
                        +(tempCsh1[t+3]*movAvgWts$first[8])
                        +(tempCsh1[t+4]*movAvgWts$first[9]))
    }else if(t == 2){
      tempMovAvg[t] <- ((tempCsh1[t-1]*movAvgWts$second[4])
                        +(tempCsh1[t]*movAvgWts$second[5])
                        +(tempCsh1[t+1]*movAvgWts$second[6])
                        +(tempCsh1[t+2]*movAvgWts$second[7])
                        +(tempCsh1[t+3]*movAvgWts$second[8])
                        +(tempCsh1[t+4]*movAvgWts$second[9]))
    }else if(t == 3){
      tempMovAvg[t] <- ((tempCsh1[t-2]*movAvgWts$third[3])
                        +(tempCsh1[t-1]*movAvgWts$third[4])
                        +(tempCsh1[t]*movAvgWts$third[5])
                        +(tempCsh1[t+1]*movAvgWts$third[6])
                        +(tempCsh1[t+2]*movAvgWts$third[7])
                        +(tempCsh1[t+3]*movAvgWts$third[8])
                        +(tempCsh1[t+4]*movAvgWts$third[9]))
    }else if(t == 4){
      tempMovAvg[t] <- ((tempCsh1[t-3]*movAvgWts$fourth[2])
                        +(tempCsh1[t-2]*movAvgWts$fourth[3])
                        +(tempCsh1[t-1]*movAvgWts$fourth[4])
                        +(tempCsh1[t]*movAvgWts$fourth[5])
                        +(tempCsh1[t+1]*movAvgWts$fourth[6])
                        +(tempCsh1[t+2]*movAvgWts$fourth[7])
                        +(tempCsh1[t+3]*movAvgWts$fourth[8])
                        +(tempCsh1[t+4]*movAvgWts$fourth[9]))
    }else if(t == tempMovlen){
      tempMovAvg[t] <- ((tempCsh1[t]*movAvgWts$last[5])
                        +(tempCsh1[t-1]*movAvgWts$last[4])
                        +(tempCsh1[t-2]*movAvgWts$last[3])
                        +(tempCsh1[t-3]*movAvgWts$last[2])
                        +(tempCsh1[t-4]*movAvgWts$last[1]))
    }else if(t == tempMovlen-1){
      tempMovAvg[t] <- ((tempCsh1[t]*movAvgWts$secondlast[5])
                        +(tempCsh1[t-1]*movAvgWts$secondlast[4])
                        +(tempCsh1[t-2]*movAvgWts$secondlast[3])
                        +(tempCsh1[t-3]*movAvgWts$secondlast[2])
                        +(tempCsh1[t-4]*movAvgWts$secondlast[1])
                        +(tempCsh1[t+1]*movAvgWts$secondlast[6]))
    }else if(t == tempMovlen-2){
      tempMovAvg[t] <- ((tempCsh1[t]*movAvgWts$thirdlast[5])
                        +(tempCsh1[t-1]*movAvgWts$thirdlast[4])
                        +(tempCsh1[t-2]*movAvgWts$thirdlast[3])
                        +(tempCsh1[t-3]*movAvgWts$thirdlast[2])
                        +(tempCsh1[t-4]*movAvgWts$thirdlast[1])
                        +(tempCsh1[t+1]*movAvgWts$thirdlast[6])
                        +(tempCsh1[t+2]*movAvgWts$thirdlast[7]))
    }else if(t == tempMovlen-3){
      tempMovAvg[t] <- ((tempCsh1[t]*movAvgWts$fourthlast[5])
                        +(tempCsh1[t-1]*movAvgWts$fourthlast[4])
                        +(tempCsh1[t-2]*movAvgWts$fourthlast[3])
                        +(tempCsh1[t-3]*movAvgWts$fourthlast[2])
                        +(tempCsh1[t-4]*movAvgWts$fourthlast[1])
                        +(tempCsh1[t+1]*movAvgWts$fourthlast[6])
                        +(tempCsh1[t+2]*movAvgWts$fourthlast[7])
                        +(tempCsh1[t+3]*movAvgWts$fourthlast[8]))
    }else{
      tempMovAvg[t] <- ((tempCsh1[t]*movAvgWts$regular[5])
                        +(tempCsh1[t-1]*movAvgWts$regular[4])
                        +(tempCsh1[t-2]*movAvgWts$regular[3])
                        +(tempCsh1[t-3]*movAvgWts$regular[2])
                        +(tempCsh1[t-4]*movAvgWts$regular[1])
                        +(tempCsh1[t+1]*movAvgWts$regular[6])
                        +(tempCsh1[t+2]*movAvgWts$regular[7])
                        +(tempCsh1[t+3]*movAvgWts$regular[8])
                        +(tempCsh1[t+4]*movAvgWts$regular[9]))
    }
  }
  return(tempMovAvg)
}

calculateCSH <- function(salesData, salesOC, salesMovAvg){
  sales <- salesData
  csh1 <- salesOC
  movAvg<- salesMovAvg
  movAvgLen <- length(movAvg)
  diffValue <- csh1 - movAvg
  salesPerct <- quantile(c(1:movAvgLen), c(inputUCL, inputLCL), type = 6)
  
  upperInt<-as.integer(salesPerct[1])
  upperDec<-salesPerct[1]%%1
  
  #rank
  diffRank<-diffValue[rank(diffValue,ties.method = "first")==upperInt]
  diffNextRank<-diffValue[rank(diffValue,ties.method = "first")==(upperInt+1)]
  subRank<- diffNextRank-diffRank
  mulDec<-upperDec*subRank
  upperFinalval<-diffRank+mulDec
  
  #Lower Final Value
  lowerInt<-as.integer(salesPerct[2])
  lowerDec<-salesPerct[2]%%1
  
  lowerDiffRank<-diffValue[rank(diffValue,ties.method = "first")==lowerInt]
  lowerDiffNextRank<-diffValue[rank(diffValue,ties.method = "first")==(lowerInt+1)]
  lowerSubRank<- lowerDiffNextRank-lowerDiffRank
  lowerMulDec<-lowerDec*lowerSubRank
  lowerFinalval<-lowerDiffRank+lowerMulDec
  
  #Upper Value
  UCL<-(1.2*upperFinalval)+movAvg
  
  #Lower Value
  LCL<-(1.2*lowerFinalval)+movAvg  
  LCL[LCL<0] <- 0
  
  #CSh Final Value
  tempMin<-pmin(sales,UCL)
  for(i in 1:movAvgLen){
    if(sales[i]>LCL[i])
      sales[i]<-tempMin[i]
    else
      sales[i]<-LCL[i]
  }
  
  cshFinal <- cbind("Difference"=diffValue,"LCL"= LCL, "UCL"= UCL,"CSH"=sales)
  return(cshFinal)
}

appendCshOutput <- function(salesDF,salesInfo, saleStart, salesCount, salesOc,salesMovAvg,csh){
  if(is.null(cshOutput)){
    cshOutput <<- cbind(salesDF,
                        "Sales Info" = salesInfo,
                        "Sales Start Index" = saleStart,
                        "Sales Count"= salesCount,
                        "Sales OC"=salesOc, 
                        "Moving Avg"= salesMovAvg,
                        csh)
    cshOutput <<- as.data.frame(cshOutput,stringsAsFactors = FALSE)
  }else{
    tempCshOut <- cbind(salesDF,
                        "Sales Info" = salesInfo,
                        "Sales Start Index" = saleStart,
                        "Sales Count"= salesCount,
                        "Sales OC"=salesOc, 
                        "Moving Avg"= salesMovAvg,
                        csh)
    cshOutput <<- rbind(cshOutput,tempCshOut)
  }
}

appendTsCshOutput <- function(salesDF){
  if(is.null(cshOutput)){
    cshOutput <<- salesDF
  }else{
    tempCshOut <- salesDF
    cshOutput <<- rbind(cshOutput,tempCshOut)
  }
}

# User defined functtions for BL Generation
getFctPeriod <- function(salesEndPeriod){
  salesEndIndex<-match(salesEndPeriod,periodMaster)
  fctStart<-salesEndIndex+1
  fctEnd<-salesEndIndex+forecastDuration
  fctRange<-periodMaster[fctStart:fctEnd]
  return(fctRange)
}

getFitPeriod <- function(saleStartPeriod, salesCount){
  saleStartIndex <- match(saleStartPeriod,periodMaster)
  salesEndIndex <- saleStartIndex + salesCount-1
  fitPeriod <- periodMaster[saleStartIndex :salesEndIndex]
  return(fitPeriod)
}

getStlSmooth <- function(stlOutput){
  start <- 0.66
  end <- 0.34
  wt1 <- 0.25
  wt2 <- 0.50
  wt3 <- 0.25
  stlSmoothened <- NULL
  for(i in 1:forecastDuration){
    if(i==1){
      stlSmoothened[i]<- ((start*stlOutput[i])+(end*stlOutput[i+1]))
    }else{
      if(i==forecastDuration)
      {
        stlSmoothened[i]<- ((start*stlOutput[i])+(end*stlOutput[i-1]))
      }else{
        stlSmoothened[i]<- ((wt1*stlOutput[i-1])+(wt2*stlOutput[i])+(wt3*stlOutput[i+1]))
      }
    }
  }
  return(stlSmoothened)
}

calculateCsETS <- function(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues, stlDecompOutput){

    csEtsFctOutput<- NULL
    csEtsFitOutput<- NULL
  
    csEtsFctOutput<- cbind("Key" = salesKey,
                      "Period"= salesFctPeriod,
                      "fctValue"= fctValues)
    csEtsFctOutput <- as.data.frame(csEtsFctOutput,stringsAsFactors = FALSE)
    
    csEtsFctOutput<- mutate(csEtsFctOutput, "MW"= substring(Period,5.6))
    
    salesFitPeriod <- getFitPeriod(saleStartPeriod,salesLen)
    
    csEtsFitOutput<- cbind("Key" = salesKey,
                      "Period"= salesFitPeriod,
                      "Value"= stlDecompOutput$time.series[,1])
    csEtsFitOutput <- as.data.frame(csEtsFitOutput,stringsAsFactors = FALSE)

    csEtsFitOutput<- mutate(csEtsFitOutput, "MW"= substring(Period,5.6))
    csEtsFitOutput<- csEtsFitOutput[c("Key", "MW", "Value")]
    csEtsFitOutput<- unique(csEtsFitOutput)
  
    csEtsFctOutput<- merge(csEtsFctOutput,csEtsFitOutput)
    csEtsFctOutput$fctValue<- as.numeric(csEtsFctOutput$fctValue)
    csEtsFctOutput$Value<- as.numeric(csEtsFctOutput$Value)
  
    csEtsFctOutput<- mutate(csEtsFctOutput, "Baseline"= (fctValue+Value))
    csEtsFctOutput<- arrange(csEtsFctOutput,Period)

    csEtsForecastStartYear <- as.numeric(substring(salesFctPeriod[1],1,4))
    csEtsForecastStartMW <- as.numeric(substring(salesFctPeriod[1],5,6))
    
    csStlOutput<- ts(csEtsFctOutput$Baseline,start = c(csEtsForecastStartYear,csEtsForecastStartMW), frequency = unitPeriodLen)
    return(csStlOutput)
    }

plotForecastGraph<- function(fctObject,salesKey){
  plot(fctObject, main = paste(salesKey,fctObject$method, sep = " --- "), xlab = "Period", ylab="Sales")
  abline(h = 0, v = 0, col = "gray60")
}

appendForecastOut<- function(salesKey,salesFctPeriod,salesForecast,salesFCtModel){
  if(is.null(fctOutput)){
    fctOutput <<- cbind("Key" = salesKey,
                        "Period" = salesFctPeriod,
                        "Value"= salesForecast,
                        "Model"=salesFCtModel)
    fctOutput <<- as.data.frame(fctOutput,stringsAsFactors = FALSE)
  }else{
    tempFctOutput <- cbind("Key" = salesKey,
                        "Period" = salesFctPeriod,
                        "Value"= salesForecast,
                        "Model"=salesFCtModel)
    fctOutput <<- rbind(fctOutput,tempFctOutput)
  }
}

appendForecastFit<- function(salesKey,fitStartPeriod, fitLen, fitValue , fitModel){
  fitPeriod <- getFitPeriod(fitStartPeriod,fitLen)
  if(is.null(fctOutput)){
    fctFit <<- cbind("Key" = salesKey,
                    "Period" = fitPeriod,
                    "Value"= fitValue,
                    "Model"=fitModel)
    fctFit <<- as.data.frame(fctFit,stringsAsFactors = FALSE)
  }else{
    tempFctFit <- cbind("Key" = salesKey,
                         "Period" = fitPeriod,
                         "Value"= fitValue,
                         "Model"=fitModel)
    fctFit <<- rbind(fctFit,tempFctFit)
  }
}

appendFctParam <- function(saleskey,fctFit,fctModel){
  
  tempfctParam<- NULL
  tempfctParam<- as.data.frame(tempfctParam, stringAsFactors = FALSE)
  
  if(fctModel == "Naive"){
      tempfctParam <- cbind("Key"= saleskey,
                            "Alpha" =  "NA",
                            "Beta" = "NA",
                            "Gamma1" = "NA",
                            "Gamma2" = "NA",
                            "Damp" = "NA",
                            "p" = "NA",
                            "d" = "NA",
                            "q"= "NA",
                            "Type" = "NA",
                            "Model" = fctModel)
      fctParam <<- rbind(fctParam,tempfctParam)
    }
  
  if(fctModel == "Mean"){
      tempfctParam <- cbind("Key"= saleskey,
                            "Alpha" =  "NA",
                            "Beta" = "NA",
                            "Gamma1" = "NA",
                            "Gamma2" = "NA",
                            "Damp" = "NA",
                            "p" = "NA",
                            "d" = "NA",
                            "q"= "NA",
                            "Type" = "NA",
                            "Model" = fctModel)
      fctParam <<- rbind(fctParam,tempfctParam)
    }
  
  if(fctModel == "Croston"){
      tempfctParam <- cbind("Key"= saleskey,
                            "Alpha" =  "NA",
                            "Beta" = "NA",
                            "Gamma1" = "NA",
                            "Gamma2" = "NA",
                            "Damp" = "NA",
                            "p" = "NA",
                            "d" = "NA",
                            "q"= "NA",
                            "Type" = "NA",
                            "Model" = fctModel)
      fctParam <<- rbind(fctParam,tempfctParam)
    }
  
  if(fctModel == "Linear Reg"){
      tempfctParam <- cbind("Key"= saleskey,
                            "Alpha" =  "NA",
                            "Beta" = "NA",
                            "Gamma1" = "NA",
                            "Gamma2" = "NA",
                            "Damp" = "NA",
                            "p" = "NA",
                            "d" = "NA",
                            "q"= "NA",
                            "Type" = "NA",
                            "Model" = fctModel)
      fctParam <<- rbind(fctParam,tempfctParam)
  }
  
  if(fctModel == "ARIMA"){
    tempfctObject <- forecast(fctFit, h=forecastDuration)
    tempfctParam <- cbind("Key"= saleskey,
                          "Alpha" =  "NA",
                          "Beta" = "NA",
                          "Gamma1" = "NA",
                          "Gamma2" = "NA",
                          "Damp" = "NA",
                          "p" = ifelse(is.null(arimaorder(fctFit)[1]), "NA", arimaorder(fctFit)[1]),
                          "d" = ifelse(is.null(arimaorder(fctFit)[2]), "NA", arimaorder(fctFit)[2]),
                          "q" = ifelse(is.null(arimaorder(fctFit)[3]), "NA", arimaorder(fctFit)[3]),
                          "Type" = ifelse(is.null(tempfctObject$method), "NA", tempfctObject$method),
                          "Model" = fctModel)
    fctParam <<- rbind(fctParam,tempfctParam)
  }
  
  if(fctModel == "TBATS"){
    tempfctObject <- forecast(fctFit, h=forecastDuration)
    tempfctParam <- cbind("Key"= saleskey,
                            "Alpha" =  ifelse(is.null(fctFit$alpha), "NA", fctFit$alpha),
                            "Beta" = ifelse(is.null(fctFit$beta), "NA", fctFit$beta),
                            "Gamma1" = ifelse(is.null(fctFit$gamma.one.values), "NA", fctFit$gamma.one.values),
                            "Gamma2" = ifelse(is.null(fctFit$gamma.two.values), "NA", fctFit$gamma.two.values),
                            "Damp" = ifelse(is.null(fctFit$damping.parameter), "NA", fctFit$damping.parameter),
                            "p" = "NA",
                            "d" = "NA",
                            "q" = "NA",
                            "Type" = ifelse(is.null(tempfctObject$method), "NA", tempfctObject$method),
                            "Model" = fctModel)
    fctParam <<- rbind(fctParam,tempfctParam)
  }
  
  if(fctModel == "ETS"){
    
      tempfctParam <- cbind("Key"= saleskey,
                            "Alpha" =  ifelse(is.null(fctFit$par["alpha"]), "NA", fctFit$par["alpha"]),
                            "Beta" = ifelse(is.null(fctFit$par["beta"]), "NA", fctFit$par["beta"]),
                            "Gamma1" = ifelse(is.null(fctFit$par["gamma"]), "NA", fctFit$par["gamma"]),
                            "Gamma2" = "NA",
                            "Damp" = ifelse(is.null(fctFit$par["phi"]), "NA", fctFit$par["phi"]),
                            "p" = "NA",
                            "d" = "NA",
                            "q"= "NA",
                            "Type" = ifelse(is.null(fctFit$method), "NA", fctFit$method),
                            "Model" = fctModel)
      fctParam <<- rbind(fctParam,tempfctParam)
  }
  
  if(fctModel ==  "DSHW"){
      tempfctParam <- cbind("Key"= saleskey,
                            "Alpha" =  ifelse(is.null(fctFit$model$alpha), "NA", fctFit$model$alpha),
                            "Beta" = ifelse(is.null(fctFit$model$beta), "NA", fctFit$model$beta),
                            "Gamma1" = ifelse(is.null(fctFit$model$gamma), "NA", fctFit$model$gamma),
                            "Gamma2" = ifelse(is.null(fctFit$model$omega), "NA", fctFit$model$omega),
                            "Damp" = ifelse(is.null(fctFit$model$phi), "NA", fctFit$model$phi),
                            "p" = "NA",
                            "d" = "NA",
                            "q"= "NA",
                            "Type" = ifelse(is.null(fctFit$method), "NA", fctFit$method),
                            "Model" = fctModel)
      fctParam <<- rbind(fctParam,tempfctParam)
    }

  if(fctModel == "CS ETS" || (fctModel== "CS ETS SM")){
          tempfctParam <- cbind("Key"= saleskey,
                            "Alpha" =  ifelse(is.null(fctFit$par["alpha"]), "NA", fctFit$par["alpha"]),
                            "Beta" = ifelse(is.null(fctFit$par["beta"]), "NA", fctFit$par["beta"]),
                            "Gamma1" = ifelse(is.null(fctFit$par["gamma"]), "NA", fctFit$par["gamma"]),
                            "Gamma2" = "NA",
                            "Damp" = ifelse(is.null(fctFit$par["phi"]), "NA", fctFit$par["phi"]),
                            "p" = "NA",
                            "d" = "NA",
                            "q"= "NA",
                            "Type" = ifelse(is.null(fctFit$method), "NA", fctFit$method),
                            "Model" = fctModel)
      fctParam <<- rbind(fctParam,tempfctParam)
    }
  
  if((fctModel == "STL ETS") || (fctModel == "STL ETS SM")){
      tempfctParam <- cbind("Key"= saleskey,
                            "Alpha" =  ifelse(is.null(fctFit$par["alpha"]), "NA", fctFit$par["alpha"]),
                            "Beta" = ifelse(is.null(fctFit$par["beta"]), "NA", fctFit$par["beta"]),
                            "Gamma1" = ifelse(is.null(fctFit$par["gamma"]), "NA", fctFit$par["gamma"]),
                            "Gamma2" = "NA",
                            "Damp" = ifelse(is.null(fctFit$par["phi"]), "NA", fctFit$par["phi"]),
                            "p" = "NA",
                            "d" = "NA",
                            "q"= "NA",
                            "Type" = ifelse(is.null(fctFit$model["method"]), "NA", as.character(fctFit$model["method"])),
                            "Model" = fctModel)
      fctParam <<- rbind(fctParam,tempfctParam)
  }
  
  if(fctModel == "NNETAR"){
    tempfctParam <- cbind("Key"= saleskey,
                          "Alpha" =  "NA",
                          "Beta" = "NA",
                          "Gamma1" = "NA",
                          "Gamma2" = "NA",
                          "Damp" = "NA",
                          "p" = "NA",
                          "d" = "NA",
                          "q"= "NA",
                          "Type" = ifelse(is.null(fctFit$method), "NA", fctFit$method),
                          "Model" = fctModel)
    fctParam <<- rbind(fctParam,tempfctParam)
  }
  
  if(fctModel == "ARIMA Reg"){
    tempfctParam <- cbind("Key"= saleskey,
                          "Alpha" =  "NA",
                          "Beta" = "NA",
                          "Gamma1" = "NA",
                          "Gamma2" = "NA",
                          "Damp" = "NA",
                          "p" = "NA",
                          "d" = "NA",
                          "q"= "NA",
                          "Type" = ifelse(is.null(fctFit$method), "NA", fctFit$method),
                          "Model" = fctModel)
    fctParam <<- rbind(fctParam,tempfctParam)
  }
}

calculateForecast <- function(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues,stlDecompOutput){
  tsinputLen <- length(tsInput)
  if(fctModel == "Linear Reg"){
    fittedVal <- fctModelFit$fitted.values
    fctObject <- forecast(fctModelFit, newdata = data.frame("salesPeriodIndex" = c((tsinputLen+1):(tsinputLen+forecastDuration))))
    fctValues <- fctObject$mean
    fctValues[fctValues<0]<- 0
    appendForecastFit(salesKey, saleStartPeriod, tsinputLen, fittedVal, fctModel)
  }else{
    fittedVal <- fctModelFit$fitted
    fctObject <- forecast(fctModelFit, h=forecastDuration)
    fctValues <- fctObject$mean
    fctValues[fctValues<0]<- 0
    if((fctModel == "STL ETS SM") && (lagIndex == 0)){
      fctValues <- getStlSmooth(fctValues)
    }
    if((fctModel == "CS ETS") || (fctModel == "CS ETS SM")){
      fctValues<- calculateCsETS(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues,stlDecompOutput)
      if((fctModel == "CS ETS SM") && (lagIndex==0))
      {
        fctValues <- getStlSmooth(fctValues)
      }
      fctValues[fctValues<0]<- 0
      fittedVal<- fittedVal + stlDecompOutput$time.series[,1]
    }
    
    appendForecastFit(salesKey, saleStartPeriod, salesLen, fittedVal, fctModel)
  }
  appendForecastOut(salesKey,salesFctPeriod,fctValues,fctModel)
  if(plotsFlag == 1){
    plotForecastGraph(fctObject,salesKey)
  }
}

getForecastValues <- function(salesKey, tsInput, tbatsTsInput, salesInfo, salesLen, saleStartPeriod, salesFctPeriod){
  fctModelFit <- NULL
  fittedVal <- NULL
  fctObject <- NULL
  fctValues <- NULL
  fctModel <- NULL
  salesPeriodIndex <- NULL
  fctPeriodIndex <- NULL
  stlDecompOutput<- NULL
  
  if ((salesInfo == "New Product") && (naiveFlag == 1)){
    fctModelFit <- naive(tsInput, h=forecastDuration)
    fittedVal <- NA
    fctModel <- "Naive"
    fctValues <- fctModelFit$mean
    fctValues[fctValues<0]<- 0
    appendFctParam(salesKey,fctModelFit,fctModel)
    appendForecastOut(salesKey,salesFctPeriod,fctValues,fctModel)
    if(plotsFlag == 1){
      plotForecastGraph(fctModelFit,salesKey)
    }
  }
  
  if ((salesInfo == "Recent")&& (meanFlag == 1)) {
    fctModelFit <- meanf(tsInput, h=forecastDuration)
    fittedVal <- fctModelFit$fitted
    fctModel <- "Mean"
    fctValues <- fctModelFit$mean
    fctValues[fctValues<0]<- 0
    appendFctParam(salesKey,fctModelFit,fctModel)
    appendForecastFit(salesKey, saleStartPeriod, salesLen, fittedVal, fctModel)
    appendForecastOut(salesKey,salesFctPeriod,fctValues,fctModel)
    if(plotsFlag == 1){
      plotForecastGraph(fctModelFit,salesKey)
    }
  }
  
  if (salesInfo == "Intermittent - Non Seasonal"){
    if(crostonFlag == 1){
      fctModelFit <- croston(tsInput, h=forecastDuration)
      fittedVal <- fctModelFit$fitted
      fctModel <- "Croston"
      fctValues <- fctModelFit$mean
      fctValues[fctValues<0]<- 0
      appendFctParam(salesKey,fctModelFit,fctModel)
      appendForecastFit(salesKey, saleStartPeriod, salesLen, fittedVal, fctModel)
      appendForecastOut(salesKey,salesFctPeriod,fctValues,fctModel)
      if(plotsFlag == 1){
        plotForecastGraph(fctModelFit,salesKey)
      }
    }
  }
  
  if ((salesInfo == "Regular - Non Seasonal")){
    if(etsFlag == 1){
      fctModelFit <- ets(tsInput, model = etsModel, damped = TRUE,upper = c(etsMaxAlpha,etsMaxBeta,etsMaxGamma,etsMaxPhi), lambda = TRUE)
      fctModel <- "ETS"
      appendFctParam(salesKey,fctModelFit,fctModel)
      calculateForecast(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues, stlDecompOutput) 
    }
    
    if(arimaFlag == 1){
      fctModelFit <- auto.arima(tsInput, max.order = 10, seasonal = FALSE, stepwise = FALSE, allowmean = TRUE, parallel = TRUE, num.cores = 4)
      fctModel <- "ARIMA"
      appendFctParam(salesKey,fctModelFit,fctModel)
      calculateForecast(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues, stlDecompOutput) 
    }
    
    if(linearRegFlag == 1){
      salesPeriodIndex <- c(1:length(tsInput))
      fctModelFit <- lm(tsInput~salesPeriodIndex, data = tsInput) 
      fctModel <- "Linear Reg"
      appendFctParam(salesKey,fctModelFit,fctModel)
      calculateForecast(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues, stlDecompOutput) 
    }
  }
  
  if ((salesInfo == "Regular - Seasonal") || (salesInfo =="Intermittent - Seasonal")){
    if(etsFlag == 1){
      fctModelFit <- ets(tsInput, model = etsModel, damped = TRUE,upper = c(etsMaxAlpha,etsMaxBeta,etsMaxGamma,etsMaxPhi), lambda = TRUE)
      fctModel <- "ETS"
      appendFctParam(salesKey,fctModelFit,fctModel)
      calculateForecast(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues, stlDecompOutput)
    }
    
    if(stlEtsFlag > 0){
      fctModelFit <- stlm(tsInput, s.window = "periodic", method = c("ets"), etsmodel = "ZZN", allow.multiplicative.trend = TRUE)
      if(stlEtsFlag == 1){
        fctModel <- "STL ETS"
      }
      if(stlEtsFlag == 2){
        fctModel <- "STL ETS SM"
      }
      appendFctParam(salesKey,fctModelFit,fctModel)
      calculateForecast(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues, stlDecompOutput)
    }
    
    if(hwFlag == 1){
      DSHWFlagKey<- filter(DSHWFlagDF, Key==salesKey)
      if(length(DSHWFlagKey$Key)!=0)
      {
        if((DSHWFlagKey$DSHWActivateFlag==1) && (min(tbatsTsInput)!=0))
        {
          #fctModelFit <- dshw(tsInput, h = 12, seasonal = c("additive","multiplicative"), damped = TRUE, level = c(80,95), fan = FALSE, initial = c("optimal","simple"))
          fctModelFit <- dshw(tbatsTsInput, h = forecastDuration)
          fittedVal <- fctModelFit$fitted
          fctModel <- "DSHW"
          appendFctParam(salesKey,fctModelFit,fctModel)
          fctValues <- fctModelFit$mean
          fctValues[fctValues<0]<- 0
          appendForecastFit(salesKey, saleStartPeriod, salesLen, fittedVal, fctModel)
          appendForecastOut(salesKey,salesFctPeriod,fctValues,fctModel)
          if(plotsFlag == 1){
            plotForecastGraph(fctModelFit,salesKey)
          }
          
          }
      }
      
    }
  
    if(tbatsFlag == 1){
      fctModelFit <- tbats(tbatsTsInput, use.arma.errors = TRUE, use.parallel = TRUE, num.cores = 4)
      fctModel <- "TBATS"
      appendFctParam(salesKey,fctModelFit,fctModel)
      calculateForecast(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues, stlDecompOutput)
    }
    
    if(csEtsFlag > 0){
      stlDecompOutput<- stl(tsInput, s.window = "periodic")
      csEtsTsInput<- seasadj(stlDecompOutput)
      fctModelFit <- ets(csEtsTsInput, model = etsModel, damped = TRUE,upper = c(etsMaxAlpha,etsMaxBeta,etsMaxGamma,etsMaxPhi), lambda = TRUE)
      if(csEtsFlag == 1){
        fctModel <- "CS ETS"
      }
      if(csEtsFlag == 2){
        fctModel <- "CS ETS SM"
      }
      appendFctParam(salesKey,fctModelFit,fctModel)
      calculateForecast(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues, stlDecompOutput)
      
    }
   
    if(nnetarFlag == 1){
      fctModelFit <- nnetar(tsInput)  
      fctModel <- "NNETAR"
      appendFctParam(salesKey,fctModelFit,fctModel)
      calculateForecast(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues, stlDecompOutput)
    }
    
    if(arimaRegFlag == 1){
      bestaic <- vector()
      for(m in 1:(unitPeriodLen/2)){
        fit <- auto.arima(tsInput, seasonal=FALSE, xreg=fourier(tsInput, K=m))
        fct <- forecast(fit, h=forecastDuration, xreg=fourier(tsInput, K=m, h=forecastDuration))
        aic <- fit$aic
        bestaic[m] <-aic
      }
      x <- which.min(bestaic)
      fctModelFit <- forecast(auto.arima(tsInput, seasonal=FALSE, xreg=fourier(tsInput, K=x)), h=forecastDuration, xreg=fourier(tsInput, K=x, h=forecastDuration))
      fctModel <- "ARIMA Reg"
      appendFctParam(salesKey,fctModelFit,fctModel)
      calculateForecast(salesKey, saleStartPeriod, salesLen, fctModelFit, fctModel, salesFctPeriod, fctValues, stlDecompOutput)
    }
  }
}

# Main Program Start ------------------------------------------------------
lagIndex <- 0
fileText <- NULL
if((runMode == 0) || (runMode == 1)){
  lagsCount <- 0
}

for (lagIndex in lagIndex:lagsCount) {
  cshInput <- cshInputAll
  if(lagIndex == 0){
    fileText <- "All"
  }else{
    fileText <- paste("Lag",lagIndex)
  }
  if(lagIndex>0){
    excludePeriod <- allSalePeriod[(allSalePeriodLen-(lagIndex * lagPeriodLen)+1):allSalePeriodLen]
    excludeLen <- length(excludePeriod)
    for (excludeIndex in 1:excludeLen) {
      cshInput<- filter(cshInput, Period != excludePeriod[excludeIndex])
    }
    cshInput <- arrange(cshInput,Key,Period)
    write.csv(cshInput, file = paste("CSH Input",fileText, ".csv"), row.names = FALSE)
    forecastDuration <- lagPeriodLen
  }
  
  # No of Keys --------------------------------------------------------------
  cshFileLen<-length(cshInput$Key)
  keyFact <- factor(cshInput$Key)
  keys <- levels(keyFact)
  keyLen<- nlevels(keyFact)
  
  # Sales Pattern Tests -----------------------------------------------------
  pb <- winProgressBar(
    label= "0% Completed",
    title = paste("Identifying Sales Patterns for",fileText, "- Please Wait"),
    min = 0,
    max = keyLen,
    width = 500
  )
  
  for (i in 1:keyLen) {
    salesDF <- filter(cshInput, Key == keys[i])
    salesKey <- salesDF$Key[1]
    salesData <- salesDF$Sales
    salesLen <- length(salesData)
    saleStart <- getSaleStart(salesData, salesLen)
    actualSales <- salesData[saleStart:salesLen]
    salesPeriod <- salesDF$Period[saleStart:salesLen]
    salesCount <- length(actualSales)
    salesInfo <- getSalesInfo(actualSales, salesCount, salesPeriod)
    appendSalesInfo(salesKey,salesInfo,salesCount,saleStart)
    setWinProgressBar(pb, i, label = paste(round(i / keyLen * 100, 0), "% Completed"))
  }
  
  setWinProgressBar(pb, 0,  title = paste("Writing Sales Pattern Results for",fileText, "- Please Wait"), label = " ")
  write.csv(salesPatterns, file = paste("Sales Patterns",fileText, ".csv"), row.names = FALSE)
  setWinProgressBar(pb, keyLen)
  
  # Cleaning Sales History --------------------------------------------------
  if(cshMethod == 0){
    cshOutput <- cbind(cshInput, "CSH" = cshInput$Sales)
  }
  if((cshMethod == 1) || (cshMethod == 2) || (cshMethod==3)){
    setWinProgressBar(pb, 0,  title =  paste("Cleaning Sales History for",fileText, "- Please Wait"), label= "0% Completed")
    for (i in 1:keyLen) {
      salesDF <- filter(cshInput, Key == keys[i])
      patternDF <- filter(salesPatterns, Key == salesDF$Key[1])
      salesInfo <- patternDF$`Sales Info`
      saleStart <- as.numeric(patternDF$`Sales Start`)
      salesCount <- as.numeric(patternDF$`Sales Count`)
      salesData <- as.numeric(salesDF$Sales)
      salesPeriod <- as.numeric(salesDF$Period)
      salesLen <- length(salesPeriod)
      saleStartPeriod <- as.integer(salesPeriod[saleStart])
      salesEndPeriod <- salesPeriod[salesLen]
      saleStartYr <- as.numeric(substring(saleStartPeriod,1,4))
      saleStartMW <- as.numeric(substring(saleStartPeriod,5,6))
      
      if((salesInfo!= "Sparse") && (salesInfo!="New Product")){
        resetInputFactors(salesInfo,salesCount)
        if(cshMethod == 1){
          salesOc<-removeOutliers(salesData)
        }
        else
        {
          if(cshMethod==3)
          {
            tempTsOut <- NULL
            salesData <- salesData[saleStart:salesLen]
            tsInput <- ts(salesData, start = c(saleStartYr,saleStartMW), frequency = unitPeriodLen)
            tscOut <- as.numeric(tsclean(tsInput))
            if(saleStart !=1){
              tempTsOut[1:(saleStart-1)]<-0
              tscOut <- c(tempTsOut,tscOut)
            }
            tscOut[tscOut<0]<-0
            salesDF <- mutate(salesDF, CSH=tscOut)
            appendTsCshOutput(salesDF)
            salesDF <- NULL
          }
          else{
            salesOc <- salesData
          }
        }
        
        if((cshMethod == 1) || (cshMethod == 2))
        {
          salesMovAvg <- calculateMovAvg(salesOc)
          csh <- calculateCSH(salesData, salesOc, salesMovAvg)
          appendCshOutput(salesDF,salesInfo, saleStart, salesCount, salesOc,salesMovAvg,csh)
        }
        
      }
      setWinProgressBar(pb, i, label = paste(round(i / keyLen * 100, 0), "% Completed"))
    }
  }
  setWinProgressBar(pb, 0,  title = paste("Writing CSH Results for",fileText, "- Please Wait"), label = " ")
  write.csv(cshOutput, file = paste("CSH Output",fileText, ".csv"), row.names = FALSE)
  setWinProgressBar(pb, keyLen)
  
  # Baseline Generation -----------------------------------------------------
  if(runMode !=4){
    if((runMode==3) && (lagIndex ==0)) {}else{
      if(plotsFlag == 1){
        pdf(paste("Baseline Plots",fileText, ".pdf"), width = 21 , height = 14)
        par(mfrow=c(3,1), cex = 1.2)
      }
      setWinProgressBar(pb, 0,  title =paste("Generating Baseline for",fileText, "- Please Wait"), label= "0% Completed")
      for (i in 1:keyLen) {
        salesDF <- filter(cshInput, Key == keys[i])
        salesKey <- salesDF$Key[1] 
        salesPeriod <- as.numeric(salesDF$Period)
        salesLen <- length(salesPeriod)
        patternDF <- filter(salesPatterns, Key == salesDF$Key[1])
        salesInfo <- patternDF$`Sales Info`
        saleStart <- as.numeric(patternDF$`Sales Start`)
        salesCount <- as.numeric(patternDF$`Sales Count`)
        salesData <- as.numeric(salesDF$Sales)
        saleStartPeriod <- as.integer(salesPeriod[saleStart])
        salesEndPeriod <- salesPeriod[salesLen]
        saleStartYr <- as.numeric(substring(saleStartPeriod,1,4))
        saleStartMW <- as.numeric(substring(saleStartPeriod,5,6))
        salesFctPeriod <- getFctPeriod(salesEndPeriod)
        tbatsTsInput <- NULL
        if(salesInfo != "Sparse"){
          if(salesInfo == "New Product"){
            saleStartPeriod <- as.integer(salesPeriod[1])
            saleStartYr <- as.numeric(substring(saleStartPeriod,1,4))
            saleStartMW <- as.numeric(substring(saleStartPeriod,5,6))
            cshTsInput <- salesData
            tsInput <- ts(cshTsInput, start = c(saleStartYr,saleStartMW), frequency = unitPeriodLen)
            getForecastValues(salesKey, tsInput, tbatsTsInput,salesInfo, salesLen, saleStartPeriod, salesFctPeriod)
          }else{
            cshDF <- filter(cshOutput, Key == keys[i])
            cshData <- as.numeric(cshDF$CSH)
            cshTsInput <- cshData[saleStart:salesLen]
            if (salesInfo == "Recent") {
              meanStartIndex <- salesLen-meanDuration+1
              if(saleStart <= meanStartIndex){
                meanStartPeriod <- salesPeriod[meanStartIndex]
                meanDataInput <- cshData[meanStartIndex:salesLen]
              }else{
                meanStartPeriod <- salesPeriod[saleStart]
                meanDataInput <- cshData[saleStart:salesLen]
              }
              meanStartYr <- as.numeric(substring(meanStartPeriod,1,4))
              meanStartMw <- as.numeric(substring(meanStartPeriod,5,6))
              tsInput <- ts(meanDataInput, start = c(meanStartYr,meanStartMw), frequency = unitPeriodLen)
              getForecastValues(salesKey, tsInput, tbatsTsInput,salesInfo, salesLen, saleStartPeriod, salesFctPeriod)
            }else{
              if((salesInfo == "Regular - Seasonal") || (salesInfo == "Intermittent - Seasonal")){
                if(lagIndex==0)
                {
                  if(min(cshTsInput)==0)
                  {
                    tempDSHWFlagDF <- cbind("Key" = salesKey,
                                           "DSHWActivateFlag" = 0)
                    
                  }else
                  {
                    tempDSHWFlagDF <- cbind("Key" = salesKey,
                                            "DSHWActivateFlag" = 1)
                  }
                  tempDSHWFlagDF <<- as.data.frame(tempDSHWFlagDF,stringsAsFactors = FALSE)
                  DSHWFlagDF <<- rbind(DSHWFlagDF,tempDSHWFlagDF)
                  tbatsTsInput <- msts(cshTsInput, start = c(saleStartYr,saleStartMW), seasonal.periods = c((unitPeriodLen/snlPeriod),unitPeriodLen))
                  tsInput <- ts(cshTsInput, start = c(saleStartYr,saleStartMW), frequency = unitPeriodLen)
                  getForecastValues(salesKey, tsInput, tbatsTsInput, salesInfo, salesLen, saleStartPeriod, salesFctPeriod)
                }else
                {
                  tbatsTsInput <- msts(cshTsInput, start = c(saleStartYr,saleStartMW), seasonal.periods = c((unitPeriodLen/snlPeriod),unitPeriodLen))
                  tsInput <- ts(cshTsInput, start = c(saleStartYr,saleStartMW), frequency = unitPeriodLen)
                  getForecastValues(salesKey, tsInput, tbatsTsInput, salesInfo, salesLen, saleStartPeriod, salesFctPeriod)
                }
               
              }else{
                tsInput <- ts(cshTsInput, start = c(saleStartYr,saleStartMW), frequency = unitPeriodLen)
                getForecastValues(salesKey, tsInput, tbatsTsInput,salesInfo, salesLen, saleStartPeriod, salesFctPeriod)
              }
            }
          }
        }
        tempDSHWFlagDF<- NULL
        setWinProgressBar(pb, i, label = paste(round(i / keyLen * 100, 0), "% Completed"))
      }
     
      if(plotsFlag == 1){
        dev.off() 
      }
      setWinProgressBar(pb, 0,  title = paste("Writing Baseline Results for",fileText, "- Please Wait"), label = " ")
      fctParam<<- filter(fctParam, Key!="DummyKey")
      fctParam[is.na(fctParam)]<- "NA"
      fctParam<- mutate(fctParam, CG_Inference= ifelse(((Model== "Naive") | (Model== "Mean") | (Model== "Croston")), "Constant", ""), UL_Inference= ifelse(((Model== "Naive") | (Model== "Mean") | (Model== "Croston")), "Constant", ""))
      fctParam$CG_Inference[((fctParam$Model== "STL ETS") | (fctParam$Model== "STL ETS SM") | (fctParam$Model== "CS ETS") | (fctParam$Model== "CS ETS SM") | (fctParam$Model== "DSHW") | (fctParam$Model== "ARIMA Reg") | (fctParam$Model=="NNETAR"))]<- "Seasonal"
      fctParam$UL_Inference[((fctParam$Model== "STL ETS") | (fctParam$Model== "STL ETS SM") | (fctParam$Model== "CS ETS") | (fctParam$Model== "CS ETS SM") | (fctParam$Model== "DSHW") | (fctParam$Model== "ARIMA Reg") | (fctParam$Model=="NNETAR"))]<- "Seasonal"
      fctParam$CG_Inference[fctParam$Model== "ARIMA"]<- "Trend"
      fctParam$CG_Inference[((fctParam$Model== "ARIMA") & (fctParam$p == fctParam$d) & (fctParam$d== fctParam$q))]<- "Constant"
      fctParam$CG_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta== "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp== "NA"))]<- "Constant"
      fctParam$UL_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta== "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp== "NA"))]<- "Constant"
      fctParam$CG_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & ((fctParam$Damp== "NA") | (fctParam$Damp== 1)))]<- "Trend"
      fctParam$UL_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & ((fctParam$Damp== "NA") | (fctParam$Damp== 1)))]<- "Trend"
      fctParam$CG_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp != "NA") & (fctParam$Damp != 1))]<- "Trend Dampened"
      fctParam$UL_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp != "NA") & (fctParam$Damp != 1))]<- "Trend"
      fctParam$CG_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp != "NA") & (fctParam$Damp != 1))]<- "Trend Dampened Seasonal"
      fctParam$UL_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp != "NA") & (fctParam$Damp != 1))]<- "Seasonal"
      fctParam$CG_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & ((fctParam$Damp== "NA") | (fctParam$Damp== 1)))]<- "Trend Seasonal"
      fctParam$UL_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & ((fctParam$Damp== "NA") |  (fctParam$Damp== 1)))]<- "Seasonal"
      fctParam$CG_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta== "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp== "NA"))]<- "Seasonal"
      fctParam$UL_Inference[((fctParam$Model== "ETS") & (fctParam$Alpha != "NA") & (fctParam$Beta== "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp== "NA"))]<- "Seasonal"
      fctParam$CG_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta== "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp== "NA"))]<- "Constant"
      fctParam$UL_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta== "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp== "NA"))]<- "Constant"
      fctParam$CG_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & ((fctParam$Damp== "NA") | (fctParam$Damp== 1)))]<- "Trend"
      fctParam$UL_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & ((fctParam$Damp== "NA") | (fctParam$Damp== 1)))]<- "Trend"
      fctParam$CG_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp != "NA") & (fctParam$Damp != 1))]<- "Trend Dampened"
      fctParam$UL_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1== "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp != "NA") & (fctParam$Damp != 1))]<- "Trend"
      fctParam$CG_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp != "NA") & (fctParam$Damp != 1))]<- "Trend Dampened Single Seasonal"
      fctParam$UL_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp != "NA") & (fctParam$Damp != 1))]<- "Seasonal"
      fctParam$CG_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2 != "NA") & (fctParam$Damp != "NA") & (fctParam$Damp != 1))]<- "Trend Dampened Double Seasonal"
      fctParam$UL_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2 != "NA") & (fctParam$Damp != "NA") & (fctParam$Damp != 1))]<- "Seasonal"
      fctParam$CG_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & ((fctParam$Damp== "NA") | (fctParam$Damp== 1)))]<- "Trend Single Seasonal"
      fctParam$UL_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & ((fctParam$Damp== "NA") | (fctParam$Damp== 1)))]<- "Seasonal"
      fctParam$CG_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2 != "NA") & ((fctParam$Damp== "NA") | (fctParam$Damp== 1)))]<- "Trend Double Seasonal"
      fctParam$UL_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta != "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2 != "NA") & ((fctParam$Damp== "NA") | (fctParam$Damp== 1)))]<- "Seasonal"
      fctParam$CG_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta == "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp== "NA"))]<- "Single Seasonal"
      fctParam$UL_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta == "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2== "NA") & (fctParam$Damp== "NA"))]<- "Seasonal"
      fctParam$CG_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta == "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2 != "NA") & (fctParam$Damp== "NA"))]<- "Double Seasonal"
      fctParam$UL_Inference[((fctParam$Model== "TBATS") & (fctParam$Alpha != "NA") & (fctParam$Beta == "NA") & (fctParam$Gamma1 != "NA") & (fctParam$Gamma2 != "NA") & (fctParam$Damp== "NA"))]<- "Seasonal"
      write.csv(fctParam, file =paste("Forecast Param",fileText, ".csv"), row.names = FALSE)
      write.csv(fctFit, file =paste("Fitted",fileText, ".csv"), row.names = FALSE)
      write.csv(fctOutput, file =paste("Baseline Output",fileText, ".csv"), row.names = FALSE)
      if(lagIndex==0)
      {
        write.csv(DSHWFlagDF, file="DSHW Model Keys.csv", row.names = FALSE)
      }
      setWinProgressBar(pb, keyLen)
    }
  }
  close(pb)
  cshInput <- NULL
  cshTsInput <- NULL
  salesPatterns <- NULL
  cshOutput <- NULL
  sdValue <- NULL
  refreshTimes <- NULL
  fctOutput <- NULL
  fctFit <- NULL
  fctParam <- NULL
  fctParam <- cbind("Key"= "DummyKey",
                    "Alpha" =  "NA",
                    "Beta" = "NA",
                    "Gamma1" = "NA",
                    "Gamma2" = "NA",
                    "Damp" = "NA",
                    "p" = "NA",
                    "d" = "NA",
                    "q" = "NA",
                    "Type" = "NA",
                    "Model" = "NA")
  fctParam <- as.data.frame(fctParam,stringsAsFactors = FALSE)
}

# Auto Method Selection ---------------------------------------------------
if(((runMode == 2) || (runMode == 3)|| (runMode == 4)) && (lagsCount>0)){
  
  patterns <- list()
  baselines <- list()
  lagIndex <- 0
  patternMvmtAll <- NULL
  patternMvmt <- NULL
  lagBaselines <- NULL
  
  for (lagIndex in lagIndex:lagsCount) {
    if(lagIndex == 0){
      fileText <- "All"
    }else{
      fileText <- paste("Lag",lagIndex)
    }
    patterns[[(lagIndex+1)]] <- read.csv( paste("Sales Patterns",fileText, ".csv"),stringsAsFactors = FALSE)
    colnames(patterns[[(lagIndex+1)]]) <- c("Key",paste("Info", fileText), paste("Count", fileText), paste("Start", fileText))
    
    if(lagIndex == 0){
      patternMvmtAll <- patterns[[(lagIndex+1)]]
      patternMvmt <- cbind("Key" = NULL)
    }else{
      tempMvmt <- merge(patternMvmtAll, patterns[[(lagIndex+1)]])
      tempMvmt <- filter(tempMvmt, tempMvmt[2]!=tempMvmt[5])
      if(is.null(patternMvmt)){
        patternMvmt <- cbind("Key" = tempMvmt[1])
      }else{
        patternMvmt <- rbind(patternMvmt, tempMvmt[1])
      }
    }
  }
  patternMvmt <- unique(patternMvmt)
  patternMvmt <- merge(patternMvmt, patterns[[1]])
  patternMvmt <- patternMvmt[1:2]
  patternMvmt <- mutate(patternMvmt, "Model" = ifelse(patternMvmt[[2]]=="Sparse", "None",
                                                              ifelse(patternMvmt[[2]] == "New Product", "Naive", 
                                                                     ifelse(patternMvmt[[2]] == "Recent", "Mean",
                                                                            ifelse(patternMvmt[[2]] == "Intermittent - Non Seasonal", "Croston","ETS")))))
  colnames(patternMvmt) <- c("Key", "Info", "Model")
  patternMvmt <- mutate(patternMvmt[c("Key","Model")], MAPE=1, Approach ="Lag")
  nonMvmtKeys <- subset(patterns[[1]], !(Key %in% patternMvmt$Key))["Key"]
  
  lagIndex <- 1
  for (lagIndex in lagIndex:lagsCount) {
    fileText <- paste("Lag",lagIndex)
    baselines[[lagIndex]] <- read.csv( paste("Baseline Output",fileText, ".csv"),stringsAsFactors = FALSE)
    colnames(baselines[[lagIndex]]) <- c("Key", "Period", "Baseline","Model")
    if(is.null(lagBaselines)){
      lagBaselines <- baselines[[lagIndex]]
    }else{
      lagBaselines <- rbind(lagBaselines, baselines[[lagIndex]])
    }
  }
  lagBaselines <- arrange(lagBaselines, Key, Model, Period)
  lagBaselinesPOC <- lagBaselines
  patternNonMvmt <- merge(nonMvmtKeys, lagBaselines)
  patternNonMvmt <- merge(patternNonMvmt, cshInputAll)
  patternNonMvmt <- arrange(patternNonMvmt, Key, Model)
  patternNonMvmt <- group_by(patternNonMvmt, Key, Model)
  patternNonMvmt <- mutate(patternNonMvmt, AbsError = abs(Sales-Baseline))
  patternNonMvmt <- arrange(patternNonMvmt,Key,Model, Period)
  patternNonMvmt <- group_by(patternNonMvmt, Key,Model)
  patternNonMvmt <- arrange(patternNonMvmt,Key,Model, Period)
  patternNonMvmt <- mutate(patternNonMvmt, AbsPE=ifelse(Sales!=0,ifelse(AbsError>=Sales, 1, AbsError/Sales),ifelse(AbsError!=0,1,0)))
  patternNonMvmt <- mutate(patternNonMvmt, MAPE=mean(AbsPE))
  patternNonMvmt <- as.data.frame(patternNonMvmt)

  patternNonMvmts <- unique(patternNonMvmt[c("Key","Model","MAPE")])
  patternNonMvmts <- mutate(patternNonMvmts, Approach ="Lag")
  patternNonMvmts <- as.data.frame(patternNonMvmts) 
  
  patternNonMvmt <- group_by(patternNonMvmts,Key)
  patternNonMvmt <- mutate(patternNonMvmt, MinMAPE = min(MAPE))
  patternNonMvmt <- filter(patternNonMvmt,MAPE==MinMAPE)
  patternNonMvmt <- patternNonMvmt[c("Key","Model","MAPE")]
  patternNonMvmt <- mutate(patternNonMvmt, Approach ="Lag")
  
  AllMAPE <- patternNonMvmts  
  AllMAPE <- rbind(AllMAPE,patternMvmt)
  write.csv(AllMAPE, file ="MAPE Results.csv", row.names = FALSE)
  
  if((runMode == 3)||(runMode == 4)){
    lagBaselinesM <- merge(lagBaselines,patternMvmt[c("Key")])
    lagBaselinesM <- filter(lagBaselinesM, Model== ifelse((Model == "ETS" | Model == "Naive" | Model == "Mean" |Model == "Croston"),Model,"NA"))
    lagBaselinesNM <- merge(lagBaselines, patternNonMvmt[c("Key", "Model")])
    lagBaselinesNM <- lagBaselinesNM[c("Key", "Period", "Baseline", "Model")]
    lagBaselineFinal <- rbind(lagBaselinesNM,lagBaselinesM)
    FAworking <- merge(lagBaselineFinal, cshInputAll)
    write.csv(FAworking, file="FA Working.csv", row.names = FALSE)
  }else{
    baselineFinal <- read.csv( "Baseline Output All .csv",stringsAsFactors = FALSE)
# 
#     finalModels <- read.csv( "Sales Patterns All .csv",stringsAsFactors = FALSE)
#     finalModels <- finalModels[c("Key","Sales Info")]
#     finalModels <- unique(finalModels)
    
    finalModels <- rbind(as.data.frame(patternMvmt),as.data.frame(patternNonMvmt))
    baselineFinal <- merge(baselineFinal, finalModels[c("Key", "Model")])
    baselineFinal <- baselineFinal[c("Key", "Period", "Value", "Model")]
    baselineFinal <- arrange(baselineFinal,Key,Period)
    write.csv(baselineFinal, file="Baseline Final.csv", row.names = FALSE)
    
    deckFile <- cshInputAll
    colnames(deckFile) <- c("Key", "Period", "Value")
    deckFile <- mutate(deckFile, "KF"= "Sales")
    
    tempCSH <- read.csv( "CSH Output All .csv",stringsAsFactors = FALSE)
    tempCSH <- tempCSH[c("Key","Period","CSH")]
    colnames(tempCSH) <- c("Key", "Period", "Value")
    tempCSH <- mutate(tempCSH, "KF"= "CSH")
    deckFile <- rbind(deckFile,tempCSH)
  
    tempBL <- baselineFinal[c("Key", "Period", "Value")]
    tempBL <- mutate(tempBL, "KF"= "R Baseline")
    deckFile <- rbind(deckFile,tempBL)
    deckFile <- merge(deckFile, finalModels[c("Key", "Model")])
    
    if(fittedFlag == 1){
      tempFitted <- read.csv( "Fitted All .csv",stringsAsFactors = FALSE)
      tempFitted <- mutate(tempFitted, "KF"= "Fitted Sales")
      tempFitted <- merge(tempFitted, finalModels[c("Key", "Model")])
      tempFitted <- tempFitted[c("Key", "Period", "Value","KF","Model")]
      write.csv(tempFitted, file="Fitted Final.csv", row.names = FALSE)
      deckFile <- rbind(deckFile,tempFitted)
    }
    
    deckFile <- arrange(deckFile,KF,Key,Period)
    write.csv(deckFile, file="Planners Deck.csv", row.names = FALSE)
    
    finalModels <- arrange(finalModels,Key)
    write.csv(finalModels, file="Selected BL Models.csv", row.names = FALSE)
    
    forecastParameters <- read.csv( "Forecast Param All .csv",stringsAsFactors = FALSE)
    finalModelsParameters<- merge(finalModels, forecastParameters)
    finalModelsParameters<- finalModelsParameters[c("Key", "Model", "MAPE", "Approach", "CG_Inference", "UL_Inference")]
    write.csv(finalModelsParameters, file="Selected BL Models Profile.csv", row.names = FALSE)
    
    lagBaselinesPOC <- merge(lagBaselinesPOC, finalModels[c("Key","Model")])
    lagBaselinesPOC <- lagBaselinesPOC[c("Key","Period","Baseline","Model")]
    lagBaselinesPOC <- arrange(lagBaselinesPOC, Key, Period, Model)
    write.csv(lagBaselinesPOC, file="POC Baselines.csv", row.names = FALSE)
  }
}
winDialog(type = c("ok"), "Process Completed!")